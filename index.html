<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒˆãƒ©ãƒƒã‚«ãƒ¼</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2em;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .sensor-data {
      font-size: 0.9em;
      color: #555;
      background: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    .emotion-selection {
      margin-top: 1em;
      background: #f0f8ff;
      padding: 10px;
      border-radius: 5px;
    }
    label { margin-right: 1em; }
    textarea {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 16px;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 10px;
    }
    button:hover {
      background: #0056b3;
    }
    .stats {
      background: #e8f5e8;
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
    }
    .warning {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    #predictionResult {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      font-size: 1.2em;
      font-weight: bold;
      text-align: center;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      border: 1px solid #ccc;
    }
    .emotion-happy { background-color: #ffeb3b; }
    .emotion-angry { background-color: #f44336; color: white; }
    .emotion-sad { background-color: #2196f3; color: white; }
    .emotion-fun { background-color: #4caf50; color: white; }
    .emotion-default { background-color: #f0f0f0; }
  </style>
</head>
<body>
  <h1>ğŸ“± ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒˆãƒ©ãƒƒã‚«ãƒ¼</h1>
  
  <div class="warning">
    <strong>æ³¨æ„:</strong> åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã¾ãŸã¯ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚
  </div>
  
  <textarea id="typingArea" rows="6" placeholder="ã“ã“ã«ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã—ã¦ãã ã•ã„"></textarea>
  
  <div class="stats">
    <p><strong>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°æ•°:</strong> <span id="typeCount">0</span></p>
    <p><strong>å‰Šé™¤å›æ•°:</strong> <span id="deleteCount">0</span></p>
    <p><strong>æ‰“ã¡è¾¼ã¿æ™‚é–“:</strong> <span id="typingTime">0.0</span> ç§’</p>
  </div>
  
  <div class="sensor-data">
    <p><strong>ğŸ“Š åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼:</strong></p>
    <p>X: <span id="accelX">-</span></p>
    <p>Y: <span id="accelY">-</span></p>
    <p>Z: <span id="accelZ">-</span></p>
    <div id="sensorStatus"></div>
  </div>
  
  <div class="emotion-selection">
    <p><strong>ğŸ˜Š ä»Šã®æ„Ÿæƒ…ã‚’é¸ã‚“ã§ãã ã•ã„:</strong></p>
    <label><input type="radio" name="emotion" value="å–œ"> ğŸ˜Š å–œ</label>
    <label><input type="radio" name="emotion" value="æ€’"> ğŸ˜  æ€’</label>
    <label><input type="radio" name="emotion" value="å“€"> ğŸ˜¢ å“€</label>
    <label><input type="radio" name="emotion" value="æ¥½"> ğŸ˜„ æ¥½</label>
  </div>
  
  <button id="saveBtn">ğŸ’¾ ä¿å­˜</button>
  <button id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>

  <div id="predictionResult" class="emotion-default">
    ã“ã“ã«æ„Ÿæƒ…ãŒäºˆæ¸¬ã•ã‚Œã¾ã™
  </div>

  <script>
    const typingArea = document.getElementById('typingArea');
    const typeCountSpan = document.getElementById('typeCount');
    const deleteCountSpan = document.getElementById('deleteCount');
    const typingTimeSpan = document.getElementById('typingTime');
    const saveBtn = document.getElementById('saveBtn');
    const resetBtn = document.getElementById('resetBtn');
    const sensorStatus = document.getElementById('sensorStatus');
    const predictionResultDiv = document.getElementById('predictionResult');

    let typeCount = 0;
    let deleteCount = 0;
    let startTime = null;
    let timer = null;
    let accelX = 0, accelY = 0, accelZ = 0;
    let maxAccelX = 0, maxAccelY = 0, maxAccelZ = 0;

    typingArea.addEventListener('keydown', (e) => {
      if (!startTime) {
        startTime = Date.now();
        timer = setInterval(() => {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          typingTimeSpan.textContent = elapsed;
        }, 100);
      }
      
      if (e.key.length === 1) {
        typeCount++;
        typeCountSpan.textContent = typeCount;
      } else if (e.key === 'Backspace') {
        deleteCount++;
        deleteCountSpan.textContent = deleteCount;
      }
    });

    typingArea.addEventListener('blur', () => {
      if (timer) clearInterval(timer);
    });

    typingArea.addEventListener('focus', () => {
      if (startTime && !timer) {
        timer = setInterval(() => {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          typingTimeSpan.textContent = elapsed;
        }, 100);
      }
    });

    if (window.DeviceMotionEvent) {
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        sensorStatus.innerHTML = '<button onclick="requestSensorPermission()">ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ã‚’å–å¾—</button>';
      } else {
        startSensorTracking();
      }
    } else {
      sensorStatus.innerHTML = '<p style="color: red;">åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>';
    }

    function requestSensorPermission() {
      DeviceMotionEvent.requestPermission()
        .then(permissionState => {
          if (permissionState === 'granted') {
            startSensorTracking();
            sensorStatus.innerHTML = '<p style="color: green;">ã‚»ãƒ³ã‚µãƒ¼è¨±å¯æ¸ˆã¿ âœ“</p>';
          } else {
            sensorStatus.innerHTML = '<p style="color: red;">ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ</p>';
          }
        })
        .catch(console.error);
    }

    function startSensorTracking() {
      window.addEventListener('devicemotion', (event) => {
        accelX = event.accelerationIncludingGravity.x || 0;
        accelY = event.accelerationIncludingGravity.y || 0;
        accelZ = event.accelerationIncludingGravity.z || 0;
        
        if (Math.abs(accelX) > Math.abs(maxAccelX)) maxAccelX = accelX;
        if (Math.abs(accelY) > Math.abs(maxAccelY)) maxAccelY = accelY;
        if (Math.abs(accelZ) > Math.abs(maxAccelZ)) maxAccelZ = accelZ;
        
        document.getElementById('accelX').textContent = accelX.toFixed(2);
        document.getElementById('accelY').textContent = accelY.toFixed(2);
        document.getElementById('accelZ').textContent = accelZ.toFixed(2);
      });
      
      if (!sensorStatus.innerHTML.includes('è¨±å¯æ¸ˆã¿')) {
        sensorStatus.innerHTML = '<p style="color: green;">ã‚»ãƒ³ã‚µãƒ¼å‹•ä½œä¸­ âœ“</p>';
      }
    }

    function predictAndDisplayEmotion() {
      const overallMaxAccel = Math.max(Math.abs(maxAccelX), Math.abs(maxAccelY), Math.abs(maxAccelZ));
      const currentTypingTime = parseFloat(typingTimeSpan.textContent);
      const deletionRate = currentTypingTime > 0 ? deleteCount / currentTypingTime : 0;

      const threshold_strong_accel = 5.0;
      const threshold_weak_accel = 2.0;
      const threshold_high_deletion = 0.5;
      const threshold_low_deletion = 0.1;

      let predictedEmotion = "ä¸æ˜";
      let emotionClass = "emotion-default";

      const isStrongTyping = overallMaxAccel > threshold_strong_accel;
      const isWeakTyping = overallMaxAccel <= threshold_weak_accel;
      const isHighDeletionRate = deletionRate > threshold_high_deletion;
      const isLowDeletionRate = deletionRate <= threshold_low_deletion;

      if (isHighDeletionRate) {
          if (isStrongTyping) {
              predictedEmotion = "æ€’";
              emotionClass = "emotion-angry";
          } else {
              predictedEmotion = "å“€";
              emotionClass = "emotion-sad";
          }
      } else if (isLowDeletionRate) {
          if (isStrongTyping) {
              predictedEmotion = "å–œ";
              emotionClass = "emotion-happy";
          } else {
              predictedEmotion = "æ¥½";
              emotionClass = "emotion-fun";
          }
      } else {
          if (isStrongTyping) {
              predictedEmotion = "å–œ";
              emotionClass = "emotion-happy";
          } else if (isWeakTyping) {
              predictedEmotion = "æ¥½";
              emotionClass = "emotion-fun";
          } else {
            predictedEmotion = "ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«";
            emotionClass = "emotion-default";
          }
      }

      predictionResultDiv.textContent = `äºˆæ¸¬ã•ã‚ŒãŸæ„Ÿæƒ…: ${predictedEmotion}`;
      predictionResultDiv.className = '';
      predictionResultDiv.classList.add(emotionClass);
    }

    saveBtn.addEventListener('click', () => {
      predictAndDisplayEmotion(); 

      const emotion = document.querySelector('input[name="emotion"]:checked');
      const data = {
        text: typingArea.value,
        typeCount: typeCount,
        deleteCount: deleteCount,
        typingTime: typingTimeSpan.textContent,
        maxAccel: { x: maxAccelX, y: maxAccelY, z: maxAccelZ },
        emotion: emotion ? emotion.value : '',
        timestamp: new Date().toISOString()
      };
      
      fetch('https://script.google.com/macros/s/AKfycbz8Pyi2wHdqlaLBvJjfySji5IKO2aasGBkREc9lAnBT5RRWJMszZG4KILEetfwDZNMy/exec', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: { 'Content-Type': 'application/json' }
      })
      .then(res => res.text())
      .then(msg => {
        alert('ãƒ‡ãƒ¼ã‚¿ã‚’Googleã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ã—ã¾ã—ãŸï¼'); 
        console.log("GASã‹ã‚‰ã®å¿œç­”:", msg);
      })
      .catch(err => {
        console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', err);
        alert('GASã¸ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
      });
    });

    resetBtn.addEventListener('click', () => {
      if (confirm('ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
        typingArea.value = '';
        typeCount = 0;
        deleteCount = 0;
        startTime = null;
        maxAccelX = maxAccelY = maxAccelZ = 0;
        
        typeCountSpan.textContent = '0';
        deleteCountSpan.textContent = '0';
        typingTimeSpan.textContent = '0.0';
        
        document.querySelectorAll('input[name="emotion"]').forEach(radio => {
          radio.checked = false;
        });
        
        if (timer) {
          clearInterval(timer);
          timer = null;
        }
        predictionResultDiv.textContent = 'ã“ã“ã«æ„Ÿæƒ…ãŒäºˆæ¸¬ã•ã‚Œã¾ã™';
        predictionResultDiv.className = 'emotion-default';
      }
    });
  </script>
</body>
</html>
